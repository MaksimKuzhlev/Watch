import {
  SlotMixin
} from "./chunk-7B2Z55OT.js";
import {
  MediaQueryController
} from "./chunk-WJZC25EU.js";
import {
  Item
} from "./chunk-ZVG6LLFE.js";
import "./chunk-USF4BTUX.js";
import {
  ListBox
} from "./chunk-Q5FXTMSP.js";
import "./chunk-3OS6HIQA.js";
import {
  ButtonMixin
} from "./chunk-NCP42DRT.js";
import "./chunk-CA7VIOY3.js";
import "./chunk-DRZGR45U.js";
import {
  processTemplates
} from "./chunk-CE2HX6X3.js";
import {
  fieldShared,
  inputFieldContainer,
  inputFieldShared
} from "./chunk-OOD7EB5R.js";
import "./chunk-BV36G4F5.js";
import "./chunk-ENZP5VPF.js";
import {
  PositionMixin
} from "./chunk-HUXAHPG4.js";
import {
  menuOverlay
} from "./chunk-MJDQ5ZI5.js";
import {
  OverlayElement
} from "./chunk-APMQ6MUQ.js";
import "./chunk-TNVMYMAL.js";
import {
  FieldMixin
} from "./chunk-QCSDD2Y2.js";
import "./chunk-VKHCUFGC.js";
import "./chunk-BRGXL5CW.js";
import "./chunk-NCTTGXQP.js";
import "./chunk-EDV4HGN5.js";
import {
  DelegateFocusMixin
} from "./chunk-WU5EZVE4.js";
import "./chunk-DVLST4BS.js";
import "./chunk-37YVODLE.js";
import "./chunk-LUEFNUZH.js";
import "./chunk-PVLUQVE7.js";
import "./chunk-TPVLHZEO.js";
import "./chunk-5HPPMUPK.js";
import "./chunk-STIA5EVJ.js";
import "./chunk-5WZR4YJM.js";
import "./chunk-XAUSENF3.js";
import "./chunk-SG4ORNH2.js";
import "./chunk-UMTV3SEQ.js";
import "./chunk-XFWHNTQC.js";
import "./chunk-NIPBZV5G.js";
import "./chunk-N7CNA5ZG.js";
import "./chunk-IA6TMM44.js";
import {
  ElementMixin
} from "./chunk-KHCP4K2D.js";
import "./chunk-VUWTYCVF.js";
import "./chunk-6QJJWYV4.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-GCGCKNGA.js";
import "./chunk-CQH3N2QY.js";
import {
  css
} from "./chunk-L3JM5TMU.js";
import {
  PolymerElement
} from "./chunk-6JYS2CNF.js";
import {
  html
} from "./chunk-W6PN6MOV.js";
import "./chunk-XKB4TURC.js";
import "./chunk-NCWCJYKY.js";
import "./chunk-LJKNN44X.js";
import "./chunk-NCN7ELFS.js";
import "./chunk-CJPRR7ZF.js";
import "./chunk-TWLJ45QX.js";

// node_modules/@vaadin/select/theme/lumo/vaadin-select-styles.js
var select = css`
  :host(:not([theme*='align'])) ::slotted([slot='value']) {
    text-align: start;
  }

  [part='input-field'] {
    cursor: var(--lumo-clickable-cursor);
  }

  [part='input-field'] ::slotted([slot='value']) {
    font-weight: 500;
  }

  [part='input-field'] ::slotted([slot='value']:not([placeholder])) {
    color: var(--lumo-body-text-color);
  }

  :host([readonly]) [part='input-field'] ::slotted([slot='value']:not([placeholder])) {
    color: var(--lumo-secondary-text-color);
  }

  /* placeholder styles */
  [part='input-field'] ::slotted([slot='value'][placeholder]) {
    color: inherit;
    transition: opacity 0.175s 0.1s;
    opacity: 0.5;
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }

  /* Highlight the toggle button when hovering over the entire component */
  :host(:hover:not([readonly]):not([disabled])) [part='toggle-button'] {
    color: var(--lumo-contrast-80pct);
  }

  :host([theme~='small']) [part='input-field'] ::slotted([slot='value']) {
    --_lumo-selected-item-height: var(--lumo-size-s);
    --_lumo-selected-item-padding: 0;
  }
`;
registerStyles("vaadin-select", [inputFieldShared, select], { moduleId: "lumo-select" });
registerStyles(
  "vaadin-select-value-button",
  css`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      padding: 0 0.25em;
      --_lumo-selected-item-height: var(--lumo-size-m);
      --_lumo-selected-item-padding: 0.5em;
    }

    ::slotted(*) {
      min-height: var(--_lumo-selected-item-height);
      padding-top: var(--_lumo-selected-item-padding);
      padding-bottom: var(--_lumo-selected-item-padding);
    }

    ::slotted(*:hover) {
      background-color: transparent;
    }
  `,
  { moduleId: "lumo-select-value-button" }
);
var selectOverlay = css`
  :host {
    --_lumo-item-selected-icon-display: block;
  }

  [part~='overlay'] {
    min-width: var(--vaadin-select-text-field-width);
  }

  /* Small viewport adjustment */
  :host([phone]) {
    top: 0 !important;
    right: 0 !important;
    bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;
    left: 0 !important;
    align-items: stretch;
    justify-content: flex-end;
  }

  :host([theme~='align-left']) {
    text-align: left;
  }

  :host([theme~='align-right']) {
    text-align: right;
  }

  :host([theme~='align-center']) {
    text-align: center;
  }
`;
registerStyles("vaadin-select-overlay", [menuOverlay, selectOverlay], { moduleId: "lumo-select-overlay" });

// node_modules/@vaadin/select/src/vaadin-select-item.js
var SelectItem = class extends Item {
  static get is() {
    return "vaadin-select-item";
  }
};
customElements.define(SelectItem.is, SelectItem);

// node_modules/@vaadin/select/src/vaadin-select-list-box.js
var SelectListBox = class extends ListBox {
  static get is() {
    return "vaadin-select-list-box";
  }
};
customElements.define(SelectListBox.is, SelectListBox);

// node_modules/@vaadin/select/src/vaadin-select-overlay.js
registerStyles(
  "vaadin-select-overlay",
  css`
    :host {
      align-items: flex-start;
      justify-content: flex-start;
    }
  `,
  { moduleId: "vaadin-select-overlay-styles" }
);
var SelectOverlay = class extends PositionMixin(OverlayElement) {
  static get is() {
    return "vaadin-select-overlay";
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.owner) {
      const menuElement = this._getMenuElement();
      this.owner._assignMenuElement(menuElement);
    }
  }
  _getMenuElement() {
    return Array.from(this.children).find((el) => el.localName !== "style");
  }
};
customElements.define(SelectOverlay.is, SelectOverlay);

// node_modules/@vaadin/select/src/vaadin-select-value-button.js
var SelectValueButton = class extends ButtonMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-select-value-button";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
          position: relative;
          outline: none;
          white-space: nowrap;
          -webkit-user-select: none;
          -moz-user-select: none;
          user-select: none;
          min-width: 0;
          width: 0;
        }

        ::slotted(*) {
          padding-left: 0;
          padding-right: 0;
          flex: auto;
        }

        /* placeholder styles */
        ::slotted(*:not([selected])) {
          line-height: 1;
        }

        .vaadin-button-container {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          text-align: inherit;
          width: 100%;
          height: 100%;
          min-height: inherit;
          text-shadow: inherit;
        }

        [part='label'] {
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          width: 100%;
          line-height: inherit;
        }
      </style>
      <div class="vaadin-button-container">
        <span part="label">
          <slot></slot>
        </span>
      </div>
    `;
  }
};
customElements.define(SelectValueButton.is, SelectValueButton);

// node_modules/@vaadin/select/src/vaadin-select.js
registerStyles("vaadin-select", [fieldShared, inputFieldContainer], { moduleId: "vaadin-select-styles" });
var Select = class extends DelegateFocusMixin(FieldMixin(SlotMixin(ElementMixin(ThemableMixin(PolymerElement))))) {
  static get is() {
    return "vaadin-select";
  }
  static get template() {
    return html`
      <style>
        ::slotted([slot='value']) {
          flex-grow: 1;
        }
      </style>

      <div class="vaadin-select-container">
        <div part="label" on-click="_onClick">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
          on-click="_onClick"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="value"></slot>
          <div part="toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-select-overlay
        position-target="[[_inputContainer]]"
        opened="{{opened}}"
        with-backdrop="[[_phone]]"
        phone$="[[_phone]]"
        theme$="[[_theme]]"
      ></vaadin-select-overlay>
    `;
  }
  static get properties() {
    return {
      items: {
        type: Array,
        observer: "__itemsChanged"
      },
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true,
        observer: "_openedChanged"
      },
      renderer: Function,
      value: {
        type: String,
        value: "",
        notify: true,
        observer: "_valueChanged"
      },
      name: {
        type: String
      },
      placeholder: {
        type: String
      },
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      _phone: Boolean,
      _phoneMediaQuery: {
        value: "(max-width: 420px), (max-height: 420px)"
      },
      _overlayElement: Object,
      _inputContainer: Object,
      _items: Object
    };
  }
  static get observers() {
    return [
      "_updateAriaExpanded(opened)",
      "_updateAriaRequired(required)",
      "_updateSelectedItem(value, _items, placeholder)",
      "_rendererChanged(renderer, _overlayElement)"
    ];
  }
  get slots() {
    return {
      ...super.slots,
      value: () => {
        const button = document.createElement("vaadin-select-value-button");
        button.setAttribute("aria-haspopup", "listbox");
        return button;
      }
    };
  }
  get _valueButton() {
    return this._getDirectSlotChild("value");
  }
  constructor() {
    super();
    const uniqueId = Select._uniqueSelectId = 1 + Select._uniqueSelectId || 0;
    this._fieldId = `${this.localName}-${uniqueId}`;
    this._boundOnKeyDown = this._onKeyDown.bind(this);
  }
  connectedCallback() {
    super.connectedCallback();
    if (this._valueButton) {
      this._valueButton.setAttribute("aria-labelledby", `${this._labelId} ${this._fieldId}`);
      this._updateAriaRequired(this.required);
      this._updateAriaExpanded(this.opened);
      this._setFocusElement(this._valueButton);
      this.ariaTarget = this._valueButton;
      this._valueButton.addEventListener("keydown", this._boundOnKeyDown);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._valueButton) {
      this._valueButton.removeEventListener("keydown", this._boundOnKeyDown);
    }
    this.opened = false;
  }
  ready() {
    super.ready();
    this._overlayElement = this.shadowRoot.querySelector("vaadin-select-overlay");
    this._inputContainer = this.shadowRoot.querySelector('[part~="input-field"]');
    this.addController(
      new MediaQueryController(this._phoneMediaQuery, (matches) => {
        this._phone = matches;
      })
    );
    processTemplates(this);
  }
  requestContentUpdate() {
    if (!this._overlayElement) {
      return;
    }
    this._overlayElement.requestContentUpdate();
    if (this._menuElement && this._menuElement.items) {
      this._updateSelectedItem(this.value, this._menuElement.items);
    }
  }
  _rendererChanged(renderer, overlay) {
    if (!overlay) {
      return;
    }
    overlay.setProperties({ owner: this, renderer: renderer || this.__defaultRenderer });
    this.requestContentUpdate();
  }
  __itemsChanged(newItems, oldItems) {
    if (newItems || oldItems) {
      this.requestContentUpdate();
    }
  }
  _assignMenuElement(menuElement) {
    if (menuElement && menuElement !== this.__lastMenuElement) {
      this._menuElement = menuElement;
      this.__initMenuItems(menuElement);
      menuElement.addEventListener("items-changed", () => {
        this.__initMenuItems(menuElement);
      });
      menuElement.addEventListener("selected-changed", () => this.__updateValueButton());
      menuElement.addEventListener("keydown", (e) => this._onKeyDownInside(e), true);
      menuElement.addEventListener(
        "click",
        () => {
          this.__userInteraction = true;
          this.opened = false;
        },
        true
      );
      menuElement.setAttribute("role", "listbox");
      this.__lastMenuElement = menuElement;
    }
  }
  __initMenuItems(menuElement) {
    if (menuElement.items) {
      this._items = menuElement.items;
      this._items.forEach((item) => item.setAttribute("role", "option"));
    }
  }
  _valueChanged(value, oldValue) {
    this.toggleAttribute("has-value", Boolean(value));
    if (value === "" && oldValue === void 0) {
      return;
    }
    this.validate();
  }
  _onClick(event) {
    event.preventDefault();
    this.opened = !this.readonly;
  }
  _onKeyDown(e) {
    if (!this.readonly && !this.opened) {
      if (/^(Enter|SpaceBar|\s|ArrowDown|Down|ArrowUp|Up)$/.test(e.key)) {
        e.preventDefault();
        this.opened = true;
      } else if (/[\p{L}\p{Nd}]/u.test(e.key) && e.key.length === 1) {
        const selected = this._menuElement.selected;
        const currentIdx = selected !== void 0 ? selected : -1;
        const newIdx = this._menuElement._searchKey(currentIdx, e.key);
        if (newIdx >= 0) {
          this.__userInteraction = true;
          this._updateAriaLive(true);
          this._menuElement.selected = newIdx;
        }
      }
    }
  }
  _onKeyDownInside(e) {
    if (/^(Tab)$/.test(e.key)) {
      this.opened = false;
    }
  }
  _openedChanged(opened, wasOpened) {
    if (opened) {
      this._updateAriaLive(false);
      if (!this._overlayElement || !this._menuElement || !this.focusElement || this.disabled || this.readonly) {
        this.opened = false;
        return;
      }
      this._overlayElement.style.setProperty(
        "--vaadin-select-text-field-width",
        `${this._inputContainer.offsetWidth}px`
      );
      const hasFocusRing = this.hasAttribute("focus-ring");
      this._openedWithFocusRing = hasFocusRing;
      if (hasFocusRing) {
        this.removeAttribute("focus-ring");
      }
      this._menuElement.focus();
    } else if (wasOpened) {
      this.focus();
      if (this._openedWithFocusRing) {
        this.setAttribute("focus-ring", "");
      }
      this.validate();
    }
  }
  _updateAriaExpanded(opened) {
    if (this._valueButton) {
      this._valueButton.setAttribute("aria-expanded", opened ? "true" : "false");
    }
  }
  _updateAriaRequired(required) {
    if (this._valueButton) {
      this._valueButton.setAttribute("aria-required", required ? "true" : "false");
    }
  }
  _updateAriaLive(ariaLive) {
    if (this._valueButton) {
      if (ariaLive) {
        this._valueButton.setAttribute("aria-live", "polite");
      } else {
        this._valueButton.removeAttribute("aria-live");
      }
    }
  }
  __attachSelectedItem(selected) {
    let labelItem;
    const label = selected.getAttribute("label");
    if (label) {
      labelItem = this.__createItemElement({ label });
    } else {
      labelItem = selected.cloneNode(true);
    }
    labelItem._sourceItem = selected;
    this.__appendValueItemElement(labelItem);
    labelItem.selected = true;
  }
  __createItemElement(item) {
    const itemElement = document.createElement(item.component || "vaadin-select-item");
    if (item.label) {
      itemElement.textContent = item.label;
    }
    if (item.value) {
      itemElement.value = item.value;
    }
    if (item.disabled) {
      itemElement.disabled = item.disabled;
    }
    return itemElement;
  }
  __appendValueItemElement(itemElement) {
    itemElement.removeAttribute("tabindex");
    itemElement.removeAttribute("role");
    itemElement.setAttribute("id", this._fieldId);
    this._valueButton.appendChild(itemElement);
  }
  __updateValueButton() {
    if (!this._valueButton) {
      return;
    }
    this._valueButton.innerHTML = "";
    const selected = this._items[this._menuElement.selected];
    this._valueButton.removeAttribute("placeholder");
    if (!selected) {
      if (this.placeholder) {
        const item = this.__createItemElement({ label: this.placeholder });
        this.__appendValueItemElement(item);
        this._valueButton.setAttribute("placeholder", "");
      }
    } else {
      this.__attachSelectedItem(selected);
      if (!this._valueChanging) {
        this._selectedChanging = true;
        this.value = selected.value || "";
        if (this.__userInteraction) {
          this.opened = false;
          this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
          this.__userInteraction = false;
        }
        delete this._selectedChanging;
      }
    }
  }
  _updateSelectedItem(value, items) {
    if (items) {
      const valueAsString = value == null ? value : value.toString();
      this._menuElement.selected = items.reduce((prev, item, idx) => {
        return prev === void 0 && item.value === valueAsString ? idx : prev;
      }, void 0);
      if (!this._selectedChanging) {
        this._valueChanging = true;
        this.__updateValueButton();
        delete this._valueChanging;
      }
    }
  }
  _shouldRemoveFocus() {
    return !this.opened;
  }
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
  checkValidity() {
    return this.disabled || !this.required || !!this.value;
  }
  __defaultRenderer(root, _select) {
    if (!this.items || this.items.length === 0) {
      root.textContent = "";
      return;
    }
    let listBox = root.firstElementChild;
    if (!listBox) {
      listBox = document.createElement("vaadin-select-list-box");
      root.appendChild(listBox);
    }
    listBox.textContent = "";
    this.items.forEach((item) => {
      listBox.appendChild(this.__createItemElement(item));
    });
  }
};
customElements.define(Select.is, Select);
/**
 * @license
 * Copyright (c) 2017 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_select_theme_lumo_vaadin-select_js.js.map
