import "./chunk-M2FW5E26.js";
import {
  Polymer
} from "./chunk-GFURQAWV.js";
import "./chunk-NKXZ7UFX.js";
import "./chunk-MLNSIFNX.js";
import "./chunk-UNTDB4AH.js";
import "./chunk-JJXNSZ6B.js";
import "./chunk-UMTV3SEQ.js";
import {
  html
} from "./chunk-W6PN6MOV.js";
import "./chunk-XKB4TURC.js";
import "./chunk-NCWCJYKY.js";
import "./chunk-LJKNN44X.js";
import "./chunk-NCN7ELFS.js";
import "./chunk-CJPRR7ZF.js";
import "./chunk-TWLJ45QX.js";

// node_modules/@flowingcode/google-map/google-map-poly.js
Polymer({
  _template: html`
    <style>
      :host {
        display: none;
      }
    </style>

    <slot id="points"></slot>
`,
  is: "google-map-poly",
  properties: {
    poly: {
      type: Object,
      readOnly: true
    },
    path: {
      type: Object,
      readOnly: true
    },
    map: {
      type: Object,
      observer: "_mapChanged"
    },
    clickable: {
      type: Boolean,
      value: false,
      observer: "_clickableChanged"
    },
    clickEvents: {
      type: Boolean,
      value: false,
      observer: "_clickEventsChanged"
    },
    closed: {
      type: Boolean,
      value: false,
      observer: "_closedChanged"
    },
    dragEvents: {
      type: Boolean,
      value: false,
      observer: "_dragEventsChanged"
    },
    editable: {
      type: Boolean,
      value: false,
      observer: "_editableChanged"
    },
    editing: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true
    },
    fillColor: {
      type: String,
      value: "",
      observer: "_fillColorChanged"
    },
    fillOpacity: {
      type: Number,
      value: 0,
      observer: "_fillOpacityChanged"
    },
    geodesic: {
      type: Boolean,
      value: false,
      observer: "_geodesicChanged"
    },
    icons: {
      type: Array,
      value: null,
      observer: "_iconsChanged"
    },
    mouseEvents: {
      type: Boolean,
      value: false,
      observer: "_mouseEventsChanged"
    },
    strokeColor: {
      type: String,
      value: "black",
      observer: "_strokeColorChanged"
    },
    strokeOpacity: {
      type: Number,
      value: 1,
      observer: "_strokeOpacityChanged"
    },
    strokePosition: {
      type: String,
      value: "center",
      observer: "_strokePositionChanged"
    },
    strokeWeight: {
      type: Number,
      value: 3,
      observer: "_strokeWeightChanged"
    },
    zIndex: {
      type: Number,
      value: 0,
      observer: "_zIndexChanged"
    }
  },
  detached() {
    if (this.poly) {
      this._listeners = {};
      this.poly.setMap(null);
    }
    if (this._pointsObserver) {
      this._pointsObserver.disconnect();
      this._pointsObserver = null;
    }
  },
  attached() {
    this.poly && this.poly.setMap(this.map);
  },
  attributeChanged(attrName) {
    if (!this.poly) {
      return;
    }
    switch (attrName) {
      case "hidden":
        this.poly.setVisible(!this.hidden);
        break;
      case "draggable":
        this.poly.setDraggable(this.draggable);
        break;
    }
  },
  _clickableChanged() {
    this.poly && this.poly.set("clickable", this.clickable);
  },
  _clickEventsChanged() {
    if (this.poly) {
      if (this.clickEvents) {
        this._forwardEvent("click");
        this._forwardEvent("dblclick");
        this._forwardEvent("rightclick");
      } else {
        this._clearListener("click");
        this._clearListener("dblclick");
        this._clearListener("rightclick");
      }
    }
  },
  _closedChanged() {
    this._mapChanged();
  },
  _dragEventsChanged() {
    if (this.poly) {
      if (this.clickEvents) {
        this._forwardEvent("drag");
        this._forwardEvent("dragend");
        this._forwardEvent("dragstart");
      } else {
        this._clearListener("drag");
        this._clearListener("dragend");
        this._clearListener("dragstart");
      }
    }
  },
  _editableChanged() {
    this.poly && this.poly.setEditable(this.editable);
  },
  _fillColorChanged() {
    this.poly && this.poly.set("fillColor", this.fillColor);
  },
  _fillOpacityChanged() {
    this.poly && this.poly.set("fillOpacity", this.fillOpacity);
  },
  _geodesicChanged() {
    this.poly && this.poly.set("geodesic", this.geodesic);
  },
  _iconsChanged() {
    this.poly && this.poly.set("icons", this.icons);
  },
  _mapChanged() {
    if (this.poly) {
      this.poly.setMap(null);
      google.maps.event.clearInstanceListeners(this.poly);
    }
    if (this.map && this.map instanceof google.maps.Map) {
      this._createPoly();
    }
  },
  _mouseEventsChanged() {
    if (this.poly) {
      if (this.mouseEvents) {
        this._forwardEvent("mousedown");
        this._forwardEvent("mousemove");
        this._forwardEvent("mouseout");
        this._forwardEvent("mouseover");
        this._forwardEvent("mouseup");
      } else {
        this._clearListener("mousedown");
        this._clearListener("mousemove");
        this._clearListener("mouseout");
        this._clearListener("mouseover");
        this._clearListener("mouseup");
      }
    }
  },
  _strokeColorChanged() {
    this.poly && this.poly.set("strokeColor", this.strokeColor);
  },
  _strokeOpacityChanged() {
    this.poly && this.poly.set("strokeOpacity", this.strokeOpacity);
  },
  _strokePositionChanged() {
    this.poly && this.poly.set("strokePosition", this._convertStrokePosition());
  },
  _strokeWeightChanged() {
    this.poly && this.poly.set("strokeWeight", this.strokeWeight);
  },
  _zIndexChanged() {
    this.poly && this.poly.set("zIndex", this.zIndex);
  },
  _buildPathFromPoints() {
    this._points = Array.prototype.slice.call(this.$.points.assignedNodes({ flatten: true })).filter((n) => n.nodeName !== "#text");
    this._building = true;
    this.path.clear();
    for (var i = 0, point; point = this._points[i]; ++i) {
      let tagName = point.tagName;
      if (tagName) {
        tagName = tagName.toLowerCase();
        if (tagName == "google-map-point") {
          this.path.push(point.getPosition());
        }
      }
    }
    this._building = false;
    this.fire("google-map-poly-path-built", this.path);
    if (this._pointsObserver) {
      return;
    }
    this._pointsObserver = new MutationObserver(this._buildPathFromPoints.bind(this));
    this._pointsObserver.observe(this, {
      subtree: true,
      attributes: true
    });
  },
  _clearListener(name) {
    if (this._listeners[name]) {
      google.maps.event.removeListener(this._listeners[name]);
      this._listeners[name] = null;
    }
  },
  _convertStrokePosition() {
    return google.maps.StrokePosition && this.strokePosition ? google.maps.StrokePosition[this.strokePosition.toUpperCase()] : 0;
  },
  _createPoly() {
    if (!this.path) {
      this._setPath(new google.maps.MVCArray());
      google.maps.event.addListener(this.path, "insert_at", this._startEditing.bind(this));
      google.maps.event.addListener(this.path, "set_at", this._updatePoint.bind(this));
      this._buildPathFromPoints();
    }
    const options = {
      clickable: this.clickable || this.draggable,
      draggable: this.draggable,
      editable: this.editable,
      geodesic: this.geodesic,
      map: this.map,
      path: this.path,
      strokeColor: this.strokeColor,
      strokeOpacity: this.strokeOpacity,
      strokePosition: this._convertStrokePosition(),
      strokeWeight: this.strokeWeight,
      visible: !this.hidden,
      zIndex: this.zIndex
    };
    if (this.closed) {
      options.fillColor = this.fillColor;
      options.fillOpacity = this.fillOpacity;
      this._setPoly(new google.maps.Polygon(options));
    } else {
      options.icons = this.icons;
      this._setPoly(new google.maps.Polyline(options));
    }
    this._listeners = {};
    this._clickEventsChanged();
    this._mouseEventsChanged();
    this._dragEventsChanged();
  },
  _forwardEvent(name) {
    this._listeners[name] = google.maps.event.addListener(this.poly, name, (event) => {
      this.fire(`google-map-poly-${name}`, event);
    });
  },
  _startEditing(index) {
    if (this._building) {
      return;
    }
    if (!this.editing) {
      this._setEditing(true);
      this._points = null;
      google.maps.event.addListenerOnce(this.map, "click", () => {
        this._setEditing(false);
        this.fire("google-map-poly-path-updated", this.path);
      });
    }
  },
  _updatePoint(index, vertex) {
    if (!this._points) {
      return;
    }
    this._points[index].latitude = vertex.lat();
    this._points[index].longitude = vertex.lng();
  }
});
//# sourceMappingURL=@flowingcode_google-map_google-map-poly_js.js.map
