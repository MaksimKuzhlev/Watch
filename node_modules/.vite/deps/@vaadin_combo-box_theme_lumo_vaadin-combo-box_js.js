import {
  ComboBoxMixin
} from "./chunk-HLW63QLQ.js";
import "./chunk-7M6UZAVZ.js";
import "./chunk-LKZC625W.js";
import "./chunk-CE2HX6X3.js";
import {
  PatternMixin
} from "./chunk-YIQTULPD.js";
import {
  InputControlMixin,
  inputFieldShared as inputFieldShared2
} from "./chunk-KIMWSYG6.js";
import {
  inputFieldShared
} from "./chunk-OOD7EB5R.js";
import "./chunk-BV36G4F5.js";
import {
  ComboBoxPlaceholder
} from "./chunk-BFM7G6QE.js";
import "./chunk-ENZP5VPF.js";
import "./chunk-HUXAHPG4.js";
import "./chunk-MJDQ5ZI5.js";
import "./chunk-APMQ6MUQ.js";
import "./chunk-TNVMYMAL.js";
import "./chunk-QCSDD2Y2.js";
import "./chunk-VKHCUFGC.js";
import "./chunk-BRGXL5CW.js";
import {
  InputController
} from "./chunk-IXNNDZUO.js";
import {
  LabelledInputController
} from "./chunk-ZMXOVGUN.js";
import "./chunk-NCTTGXQP.js";
import "./chunk-EDV4HGN5.js";
import "./chunk-WU5EZVE4.js";
import "./chunk-DVLST4BS.js";
import "./chunk-37YVODLE.js";
import "./chunk-LUEFNUZH.js";
import "./chunk-PVLUQVE7.js";
import "./chunk-TPVLHZEO.js";
import "./chunk-5HPPMUPK.js";
import "./chunk-STIA5EVJ.js";
import "./chunk-5WZR4YJM.js";
import "./chunk-XAUSENF3.js";
import "./chunk-SG4ORNH2.js";
import "./chunk-UMTV3SEQ.js";
import "./chunk-XFWHNTQC.js";
import "./chunk-NIPBZV5G.js";
import "./chunk-N7CNA5ZG.js";
import "./chunk-IA6TMM44.js";
import {
  ElementMixin
} from "./chunk-KHCP4K2D.js";
import "./chunk-VUWTYCVF.js";
import "./chunk-6QJJWYV4.js";
import {
  ThemableMixin,
  registerStyles
} from "./chunk-GCGCKNGA.js";
import "./chunk-CQH3N2QY.js";
import {
  css
} from "./chunk-L3JM5TMU.js";
import {
  PolymerElement
} from "./chunk-6JYS2CNF.js";
import {
  html
} from "./chunk-W6PN6MOV.js";
import "./chunk-XKB4TURC.js";
import "./chunk-NCWCJYKY.js";
import "./chunk-LJKNN44X.js";
import "./chunk-NCN7ELFS.js";
import "./chunk-CJPRR7ZF.js";
import "./chunk-TWLJ45QX.js";

// node_modules/@vaadin/combo-box/theme/lumo/vaadin-combo-box-styles.js
var comboBox = css`
  :host {
    outline: none;
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }
`;
registerStyles("vaadin-combo-box", [inputFieldShared, comboBox], { moduleId: "lumo-combo-box" });

// node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js
var ComboBoxDataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged"
      },
      size: {
        type: Number,
        observer: "_sizeChanged"
      },
      dataProvider: {
        type: Object,
        observer: "_dataProviderChanged"
      },
      _pendingRequests: {
        value: () => {
          return {};
        }
      },
      __placeHolder: {
        value: new ComboBoxPlaceholder()
      },
      __previousDataProviderFilter: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "_dataProviderFilterChanged(filter)",
      "_warnDataProviderValue(dataProvider, value)",
      "_ensureFirstPage(opened)"
    ];
  }
  ready() {
    super.ready();
    this.$.dropdown.addEventListener("index-requested", (e) => {
      const index = e.detail.index;
      const currentScrollerPos = e.detail.currentScrollerPos;
      const allowedIndexRange = Math.floor(this.pageSize * 1.5);
      if (this._shouldSkipIndex(index, allowedIndexRange, currentScrollerPos)) {
        return;
      }
      if (index !== void 0) {
        const page = this._getPageForIndex(index);
        if (this._shouldLoadPage(page)) {
          this._loadPage(page);
        }
      }
    });
  }
  _dataProviderFilterChanged(filter) {
    if (this.__previousDataProviderFilter === void 0 && filter === "") {
      this.__previousDataProviderFilter = filter;
      return;
    }
    if (this.__previousDataProviderFilter !== filter) {
      this.__previousDataProviderFilter = filter;
      this._pendingRequests = {};
      this.loading = this._shouldFetchData();
      this.size = void 0;
      this.clearCache();
    }
  }
  _shouldFetchData() {
    if (!this.dataProvider) {
      return false;
    }
    return this.opened || this.filter && this.filter.length;
  }
  _ensureFirstPage(opened) {
    if (opened && this._shouldLoadPage(0)) {
      this._loadPage(0);
    }
  }
  _shouldSkipIndex(index, allowedIndexRange, currentScrollerPos) {
    return currentScrollerPos !== 0 && index >= currentScrollerPos - allowedIndexRange && index <= currentScrollerPos + allowedIndexRange;
  }
  _shouldLoadPage(page) {
    if (!this.filteredItems || this._forceNextRequest) {
      this._forceNextRequest = false;
      return true;
    }
    const loadedItem = this.filteredItems[page * this.pageSize];
    if (loadedItem !== void 0) {
      return loadedItem instanceof ComboBoxPlaceholder;
    }
    return this.size === void 0;
  }
  _loadPage(page) {
    if (!this._pendingRequests[page] && this.dataProvider) {
      this.loading = true;
      const params = {
        page,
        pageSize: this.pageSize,
        filter: this.filter
      };
      const callback = (items, size) => {
        if (this._pendingRequests[page] === callback) {
          const filteredItems = this.filteredItems ? [...this.filteredItems] : [];
          filteredItems.splice(params.page * params.pageSize, items.length, ...items);
          this.filteredItems = filteredItems;
          if (this._isValidValue(this.value) && this._getItemValue(this.selectedItem) !== this.value) {
            this._selectItemForValue(this.value);
          }
          if (!this.opened && !this.hasAttribute("focused")) {
            this._commitValue();
          }
          this.size = size;
          delete this._pendingRequests[page];
          if (Object.keys(this._pendingRequests).length === 0) {
            this.loading = false;
          }
        }
      };
      if (!this._pendingRequests[page]) {
        this._pendingRequests[page] = callback;
        this.dataProvider(params, callback);
      }
    }
  }
  _getPageForIndex(index) {
    return Math.floor(index / this.pageSize);
  }
  clearCache() {
    if (!this.dataProvider) {
      return;
    }
    this._pendingRequests = {};
    const filteredItems = [];
    for (let i = 0; i < (this.size || 0); i++) {
      filteredItems.push(this.__placeHolder);
    }
    this.filteredItems = filteredItems;
    if (this._shouldFetchData()) {
      this._forceNextRequest = false;
      this._loadPage(0);
    } else {
      this._forceNextRequest = true;
    }
  }
  _sizeChanged(size = 0) {
    const filteredItems = (this.filteredItems || []).slice(0, size);
    for (let i = 0; i < size; i++) {
      filteredItems[i] = filteredItems[i] !== void 0 ? filteredItems[i] : this.__placeHolder;
    }
    this.filteredItems = filteredItems;
    this._flushPendingRequests(size);
  }
  _pageSizeChanged(pageSize, oldPageSize) {
    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {
      this.pageSize = oldPageSize;
      throw new Error("`pageSize` value must be an integer > 0");
    }
    this.clearCache();
  }
  _dataProviderChanged(dataProvider, oldDataProvider) {
    this._ensureItemsOrDataProvider(() => {
      this.dataProvider = oldDataProvider;
    });
    this.clearCache();
  }
  _ensureItemsOrDataProvider(restoreOldValueCallback) {
    if (this.items !== void 0 && this.dataProvider !== void 0) {
      restoreOldValueCallback();
      throw new Error("Using `items` and `dataProvider` together is not supported");
    } else if (this.dataProvider && !this.filteredItems) {
      this.filteredItems = [];
    }
  }
  _warnDataProviderValue(dataProvider, value) {
    if (dataProvider && value !== "" && (this.selectedItem === void 0 || this.selectedItem === null)) {
      const valueIndex = this._indexOfValue(value, this.filteredItems);
      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {
        console.warn(
          "Warning: unable to determine the label for the provided `value`. Nothing to display in the text field. This usually happens when setting an initial `value` before any items are returned from the `dataProvider` callback. Consider setting `selectedItem` instead of `value`"
        );
      }
    }
  }
  _flushPendingRequests(size) {
    if (this._pendingRequests) {
      const lastPage = Math.ceil(size / this.pageSize);
      const pendingRequestsKeys = Object.keys(this._pendingRequests);
      for (let reqIdx = 0; reqIdx < pendingRequestsKeys.length; reqIdx++) {
        const page = parseInt(pendingRequestsKeys[reqIdx]);
        if (page >= lastPage) {
          this._pendingRequests[page]([], size);
        }
      }
    }
  }
};

// node_modules/@vaadin/combo-box/src/vaadin-combo-box.js
registerStyles("vaadin-combo-box", inputFieldShared2, { moduleId: "vaadin-combo-box-styles" });
var ComboBox = class extends ComboBoxDataProviderMixin(
  ComboBoxMixin(PatternMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))))
) {
  static get is() {
    return "vaadin-combo-box";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <div class="vaadin-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div id="toggleButton" part="toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-combo-box-dropdown
        id="dropdown"
        opened="[[opened]]"
        renderer="[[renderer]]"
        position-target="[[_positionTarget]]"
        restore-focus-on-close="[[__restoreFocusOnClose]]"
        restore-focus-node="[[inputElement]]"
        _focused-index="[[_focusedIndex]]"
        _item-id-path="[[itemIdPath]]"
        _item-label-path="[[itemLabelPath]]"
        loading="[[loading]]"
        theme="[[_theme]]"
      ></vaadin-combo-box-dropdown>
    `;
  }
  static get properties() {
    return {
      _positionTarget: {
        type: Object
      }
    };
  }
  get clearElement() {
    return this.$.clearButton;
  }
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._positionTarget = this.shadowRoot.querySelector('[part="input-field"]');
    this._toggleElement = this.$.toggleButton;
  }
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.validate();
    }
  }
  _shouldRemoveFocus(event) {
    if (event.relatedTarget === this.$.dropdown.$.overlay) {
      event.composedPath()[0].focus();
      return false;
    }
    return true;
  }
  _onClearButtonClick(event) {
    event.stopPropagation();
    this._handleClearButtonClick(event);
  }
  _onHostClick(event) {
    const path = event.composedPath();
    if (path.includes(this._labelNode) || path.includes(this._positionTarget)) {
      super._onHostClick(event);
    }
  }
};
customElements.define(ComboBox.is, ComboBox);
/**
 * @license
 * Copyright (c) 2015 - 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
//# sourceMappingURL=@vaadin_combo-box_theme_lumo_vaadin-combo-box_js.js.map
